import sys
import logging
from string import Template

import numpy as np

import ANNarchy_future.generator as generator


class SingleThreadGenerator(object):

    """Generates the C++ code for single-threaded simulation.

    """

    def __init__(self, description:dict, backend:str):

        """
        Args:

            description: dictionary passed by `Network`.
            backend: 'single', 'openmp', 'cuda' or 'mpi'.
        """
        
        self.description:dict = description
        self.backend = backend

        self.neuron_classes:dict = {}
        self.neuron_exports:dict = {}
        self.neuron_wrappers:dict = {}

        self.synapse_classes:dict = {}

    def generate(self):
        """Generates the necessary C++ classes.

        * Neuron classes.
        * Synapse classes.
        * Main class.
        * Bindings (Cython or gRPC) depending on the backend.
        """

        # Generate Neuron classes 
        self.generate_neurons() 

        # Generate Synapse classes 
        self.generate_synapses() 

        # Generate ANNarchy.h
        self.generate_header()

        # Generate ANNarchyCore.pyx
        self.generate_cython()

        # Generate Makefile
        self.generate_makefile()

    def generate_neurons(self):
        """Generates one C++ class per neuron definition by calling `SingleThread.PopulationGenerator`.
                
        Sets:
        
            self.neuron_classes (dict)
            self.neuron_exports (dict)
            self.neuron_wrappers (dict)
        """

        # Generate Neuron classes        
        neurons = self.description['neurons']

        for name, parser in neurons.items():

            parser = generator.SingleThread.PopulationGenerator(name, parser)

            # C++ class
            code = parser.generate()
            self.neuron_classes[name] = code

            # Cython export
            code = parser.cython_export()
            self.neuron_exports[name] = code

            # Cython wrapper
            code = parser.cython_wrapper()
            self.neuron_wrappers[name] = code

    def generate_synapses(self):
        """Generates one C++ class per synapse definition by calling `SingleThread.ProjectionGenerator`.
        
        Sets:
        
            self.synapse_classes (dict)
        """

        # Generate Synapse classes        
        synapses = self.description['synapses']

        for name, parser in synapses.items():

            parser = generator.SingleThread.ProjectionGenerator(name, parser)
            code = parser.generate()

            self.synapse_classes[name] = code

    def generate_header(self):
        """Generates ANNarchy.h

        Sets:

            self.annarchy_h

        """

        neuron_includes = ""
        for name in self.neuron_classes.keys():
            neuron_includes += Template('#include "$name.h"\n').substitute(name=name)

        synapse_includes = ""
        #for name in self.synapse_classes.keys():
        #    synapse_includes += Template('#include "$name.h"\n').substitute(name=name)


        # Generate ANNarchy.h
        self.annarchy_h = Template("""#pragma once

#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <deque>
#include <queue>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <stdlib.h>
#include <string.h>
#include <cmath>
#include <random>

// Neuron definitions
$neuron_includes

// Synapse definitions
$synapse_includes
        """).substitute(
            neuron_includes = neuron_includes,
            synapse_includes = synapse_includes,
        )


    def generate_makefile(self):
        """Generates a Makefile.
        """

        # Python version
        python_version = "%(major)s.%(minor)s" % {'major': sys.version_info[0],
                                              'minor': sys.version_info[1]}

        # Include path to Numpy is not standard on all distributions
        numpy_include = np.get_include()

        makefile = Template("""# Makefile generated by ANNarchy
all:
\tcython3 -3 --cplus ANNarchyCore.pyx 
\tg++ -march=native -O3 -shared -fPIC -fpermissive -std=c++11 \\
\t\t`/usr/bin/python3-config --includes` \\
\t\t-I$numpy_include \\
\t\t*.cpp -o ANNarchyCore.so \\
\t\t-lpython$python_version \\
\t\t-L/usr/lib 

clean:
\trm -rf *.o
\trm -rf *.so
""")
        self.makefile = makefile.substitute(
            numpy_include = numpy_include,
            python_version = python_version,
        )

    def generate_cython(self):
        """Generates Cython bindings.

        """

        # Export from C++
        neuron_export = ""
        for _, code in self.neuron_exports.items():
            neuron_export += code

        self.cython_bindings = Template("""# distutils: language = c++
from libcpp.vector cimport vector

cdef extern from "ANNarchy.h":

$neuron_export

""").substitute(
            neuron_export=neuron_export,
        )

        # Cython wrapper
        neuron_wrapper = ""
        population_creator = ""
        neuron_imports = ""
        for name, code in self.neuron_wrappers.items():
            neuron_wrapper += code
            population_creator += Template("""
    def _add_$name(self, int size, double dt):

        pop = py$name(size, dt)
        self.populations.append(pop)""").substitute(
            name=name,
        )
            neuron_imports += Template("""
from ANNarchyBindings cimport $name""").substitute(name=name)

        self.cython_network = Template("""# distutils: language = c++
cimport cython
from libcpp.vector cimport vector
cimport numpy as np
import numpy as np

$neuron_imports

$neuron_wrapper

cdef class Network(object):

    cdef list populations

    def __cinit__(self):

        self.populations = []

    def __dealloc__(self):
        del self.populations[0]

    def population(self, int idx):
        return self.populations[idx]

    @cython.boundscheck(False) # turn off bounds-checking for entire function
    @cython.wraparound(False)  # turn off negative index wrapping for entire function
    def step(self):
        # Neural updates
        for pop in self.populations:
            pop.update()
        # Spike emission
        for pop in self.populations:
            pop.spike()
        # Reset
        for pop in self.populations:
            pop.reset()

$population_creator

""").substitute(
    neuron_wrapper = neuron_wrapper,
    population_creator = population_creator,
    neuron_imports = neuron_imports,
)